字符串对象共有 4个方法，可以使用正则表达式：match()、replace()、search()和split()

Number 对象
Number.isFinite()、Number.isNaN()
ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效。

parseInt()、parseFloat()
ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。

Number.isInteger() 
会有误判，不适合精度要求高的数字

Number.EPSILON
JavaScript 能够表示的最小精度。
Number.EPSILON === Math.pow(2, -52) //true

Number.isSafeInteger()

Math 对象
Math.trunc() 去除一个数的小数部分
Math.sign() 用来判断一个数到底是正数、负数、还是零。
Math.cbrt 方法用于计算一个数的立方根。
Math.clz32 方法返回一个数的 32 位无符号整数形式有多少个前导 0。
Math.imul()
Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。
Math.hypot方法返回所有参数的平方和的平方根。
对数方法：
Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。
Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。
Math.log10(x)返回以 10 为底的x的对数。
Math.log2(x)返回以 2 为底的x的对数。

七、函数的扩展

箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。
this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。

尾递归优化
蹦床函数  带有状态变量的优化函数
es2017 函数参数支持尾逗号

八、数组的扩展
1.扩展运算符 ...，好比 rest 参数的逆运算
// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);

替代函数的 apply 方法
应用：复制、合并数组（替换 concat 方法）、与解构赋值结合、字符串、计算4字节字符串长度

用于具有 Iterator 接口的对象扩展，如 map, set

2.Array.from() —— 用于将类数组对象和可遍历的对象转为数组
等同于：[].slice.call();

实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。
任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。
Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。

3.Array.of() —— 用于将一组值转换为数组。
等同于：[].slice.call();

这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。

4.copyWithin() —— 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。

5.find 和 findIndex
回调函数含3个参数：value, index, arr
这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。
[NaN].findIndex(y => Object.is(NaN, y))
indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。

6.fill —— 使用给定值填充数组

7.entries()，keys() 和 values() —— 都返回一个遍历器对象

8.includes() 是否包含元素
替代 indexOf 
Map 和 Set 数据结构有一个has方法，需要注意与includes区分。
Map 结构的has方法，是用来查找键名的;
Set 结构的has方法，是用来查找值的;

9.flat()，flatMap()
flat:将嵌套数组拉平为一维数组
flatmap: 先执行map函数，再拉平，只能拉平一层

10.空位
es5 中：
forEach(), filter(), reduce(), every() 和some()都会跳过空位。
map()会跳过空位，但会保留这个值
join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。
es6 中：
明确将空位转为undefined。

九、对象的扩展
1。属性的简洁表示
ES6 允许在对象之中，直接写变量。

2.属性名表达式
属性名表达式与简洁表示法，不能同时使用，会报错。属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]

3.方法的name属性
get,set 方法，属性名为 “get/set” + 函数名
bind 绑定的函数, 属性名为 "bound" + 函数名
new 构造函数创建的函数，属性名为 "anonymous"
方法名为 symbol 值的函数，属性名为 symbol 的描述

4.属性的可枚举性和遍历
Object.getOwnPropertyDescriptor(obj, 'foo')
{ 
	value:
	writable:
	enumerable:
	configurable:
}
for。。in , Object.keys(),JSON.stringfy(),Object.assign()会忽略不可枚举的属性，只有for..in会返回继承属性，因此，应尽量不要使用 for 循环，而用Object.keys代替

ES6 有 5 种方法可以遍历对象的属性
(1)for...in
(2)Object.keys()
(3)Object.getOwnPropertyNames()
(4)Object.getOwnPropertySymbols() 返回所有 symbol 属性的键名
(5)Reflect.ownKeys() 返回所有，包括 symbol 和不可枚举属性

以上5种方法遍历对象，都遵守同样的次序
先数值（升序）- 字符串（时间升序） - symbol（时间升序）

5.super
只能用在对象的方法之中
super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。

6.对象的扩展运算符（等同于 Object.assign()）
ES2018 将这个运算符引入了对象。
将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。
右侧对象不能为null或undefined，解构赋值必须是最后一个参数
解构赋值的拷贝是浅拷贝，不能复制继承自原型对象的属性。
如果扩展运算符后面不是对象，则会自动将其转为对象。（字符串转换成类数组）

继承拷贝方案：
// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)

合并对象
{...a,...b} == Object.assign({},a,b)

十、对象的新增方法
1.Object.is()
与严格比较运算符（===）的行为基本一致。处理了+0和-0，NaN等于自身

2.Object.assgin()
处理对象合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。
非对象参数出现在源对象的位置，会先转成对象，无法转的则跳过。
只有字符串的包装对象，会产生可枚举属性。Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。

浅拷贝、同名属性替换、数组、取值函数的处理
用途：
为对象添加属性、方法；克隆对象；合并多个对象；为属性指定默认值

3.Object.getOwnPropertyDescriptors()
返回指定对象所有自身属性（非继承属性）的描述对象。
解决 Object.assgin() 无法拷贝 get 和 set 方法属性的问题
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));

配合Object.create()方法，将对象属性克隆到一个新对象。浅拷贝

4.__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()

__proto__属性
（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。不作为正式对外API，仅浏览器下部署，最好使用propertytypeof
代替

Object.setPropertyOf()
作用与__proto__ 相同，用来设置对象的 prototype 属性，返回参数对象本身
如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。

Object.getPrototypeOf()
该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。

5.Object.keys()，Object.values()，Object.entries()
ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。

ES2017年引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。
Object.values只返回对象自身的可遍历属性。
Object.create() 第二个参数中的属性默认是不可遍历的
Object.values会过滤属性名为 Symbol 值的属性。
如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。
Symbol 属性会被忽略。

Object.entries()
Object.entries的基本用途是遍历对象的属性。
Object.entries方法的另一个用处是，将对象转为真正的Map结构。

6.Object.fromEntries() 
Object.fromEntries()方法是Object.entries()的逆操作，用于将一个键值对数组转为对象。
特别适合将 Map 结构转为对象。

十一、Symbol
1.js 的第七种数据类型
如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。

转成字符串
let s1 = Symbol('foo');
s1.toString() // "Symbol(foo)"

Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。

Symbol 值不能与其他类型的值进行运算，但可以显示转换为字符串或布尔，不能转为数值

2.作为属性名的Symbol

Symbol 值作为对象属性名时，不能用点运算符，只能使用方括号
const mySymbol = Symbol();
const a = {};
a.mySymbol = 'Hello!';  //无效，.后面默认是字符串

Symbol 值作为属性名时，该属性是公开属性。

3.实例：消除魔术字符串

4.属性名的遍历
Symbol 属性不会出现在 for...in/for...of/Object.keys()/Object.getOwnPropertyNames()、JSON.stringify(),
但可通过 Object.getOwnPropertySymbols 方法获取
Reflect.ownKeys 方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。

5.Symbol.for()，Symbol.keyFor() 
登记在全局环境中供搜索，先检查给定的key是否已经存在，如果不存在才会新建一个值。

Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。

6.内置的 Symbol 值
其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。
Symbol.isConcatSpreadable 
Symbol.species
Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。
Symbol.match、Symbol.replace、Symbol.split、iterator
指向一个方法，当该对象被String.prototype.match/replace/split 调用时，返回该方法的值。

十二、Set 和 Map 数据结构
1.Set
值唯一的数组
// 去除数组的重复成员
[...new Set(array)]
Array.from(new Set(array));
//去除字符串中的重复字符
[...new Set('ababbc')].join('')
// "abc"

向 Set 加入值的时候，不会发生类型转换，判断相等的算法类似 === ，且 NaN ==== NaN

Set 结构的属性：
constructor
size

Set 结构的方法：
操作方法：
add
delete
has
clear
遍历方法：
keys()
values()
entries()
forEach()

Set的遍历顺序就是插入顺序
Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。

2.WeakSet
不重复值的集合
不同于Weak：
首先，WeakSet 的成员只能是对象，而不能是其他类型的值。
其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用。
因此 ES6 规定 WeakSet 不可遍历。

WeakSet 的方法：
add()
delete()
has()

没有 size 和 forEach 方法
WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

3.Map
Object 键值只能是字符串，Map 解决该问题
Map构造函数接受数组作为参数
如果对同一个键多次赋值，后面的值将覆盖前面的值。
如果读取一个未知的键，则返回undefined。
读取一个未知的键，则返回undefined。

实例的属性和操作方法
size 
set(key,value) 如果key已经有值，则键值会被更新，否则就新生成该键。
get(key)
has(key)
delete(key)
clear()

遍历方法：
keys()
values()
entries()
forEach()

Map 的遍历顺序就是插入顺序。
Map 结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。
map[Symbol.iterator] === map.entries

4.WeakMap
WeakMap只接受对象作为键名（null除外），不接受其他类型的值作为键名。
不可遍历，只有4个方法get()、set()、has()、delete()


十三、Proxy
拦截器
用于修改某些操作的默认行为，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。
一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。
Proxy 实例也可以作为其他对象的原型对象。
同一个拦截器函数，可以设置拦截多个操作。

Proxy 一共支持13种截操作：
get 
可以继承
可以实现对数组的负数索引
可以实现对函数名链式使用
可以实现一个生成各种 DOM 节点的通用函数dom
总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。

set
用来拦截某个属性的赋值操作
使用Proxy保证属性值符合要求。
利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。
如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。
严格模式下，set代理如果没有返回true，就会报错。

has
has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。
使用has方法隐藏某些属性（如 _），不被in运算符发现。
虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。

deleteProperty
deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。
目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。

ownKeys
ownKeys方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。
Object.getOwnPropertyNames()
Object.getOwnPropertySymbols()
Object.keys()
for...in循环
使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。
目标对象上不存在的属性
属性名为 Symbol 值
不可遍历（enumerable）的属性
ownKeys方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。
如果目标对象自身包含不可配置的属性，则该属性必须被ownKeys方法返回，否则报错。

var obj = {};
getOwnPropertyDescriptor
getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者undefined。

defineProperty
defineProperty方法拦截了Object.defineProperty操作。
如果目标对象不可扩展（non-extensible），则defineProperty不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty方法不得改变这两个设置。

preventExtensions
preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。

getPrototypeOf
getPrototypeOf方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。
Object.prototype.__proto__
Object.prototype.isPrototypeOf()
Object.getPrototypeOf()
Reflect.getPrototypeOf()
instanceof
getPrototypeOf方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（non-extensible）， getPrototypeOf方法必须返回目标对象的原型对象。

isExtensible
拦截Object.isExtensible操作。

setPrototypeOf
方法主要用来拦截Object.setPrototypeOf方法。

apply
apply方法拦截函数的调用、call和apply操作。

construct
construct方法用于拦截new命令，下面是拦截对象的写法。
construct方法返回的必须是一个对象，否则会报错。

3.Proxy.revocable
方法返回一个可取消的 Proxy 实例。
let {proxy, revoke} = Proxy.revocable(target, handler)

4.this 问题


十四、Reflect
与Proxy对象一样，也是ES6为了操作对象而提供新的API。
1.设计目的：
1）将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。
2）修改某些Object方法的返回结果，让其变得更合理。
3）让Object操作都变成函数行为。
4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。

2.静态方法
大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。
共性：如果第一个参数不是对象，会报错

Reflect对象一共有 13 个静态方法。

Reflect.apply(target, thisArg, args)
等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。

Reflect.construct(target, args)
等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。

Reflect.get(target, name, receiver)查找并返回target对象的name属性，如果没有该属性，则返回undefined。
如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。

Reflect.set(target, name, value, receiver)
设置target对象的name属性等于value。
如果name属性设置了赋值函数，则赋值函数的this绑定receiver。
Reflect.set一旦传入receiver，就会将属性赋值到receiver上面（即obj），导致触发defineProperty拦截。

Reflect.defineProperty(target, name, desc)
基本等同于Object.defineProperty，用来为对象定义属性。

Reflect.deleteProperty(target, name)
等同于delete obj[name]，用于删除对象的属性。

Reflect.has(target, name)
对应name in obj里面的in运算符。
删除成功，返回true，否则，返回false


Reflect.ownKeys(target)
用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。

Reflect.isExtensible(target)
对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。

Reflect.preventExtensions(target)

Reflect.getOwnPropertyDescriptor(target, name)
基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象

Reflect.getPrototypeOf(target)
用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。
Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果参数不是对象，Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。

Reflect.setPrototypeOf(target, prototype)
用于设置目标对象的原型（prototype），对应Object.setPrototypeOf(obj, newProto)方法。它返回一个布尔值，表示是否设置成功。
如果第一个参数是undefined或null，Object.setPrototypeOf和Reflect.setPrototypeOf都会报错。

3.实例：使用 Proxy 实现观察者模式

十五、Promise 对象
1.Promise 的含义
所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。
Promise 对象的特点：
（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。
（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。

Promise 优点：
有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。

Promise 缺点：
首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。

2.基本用法
const promise = new Promise(function(resolve,reject){
	//... some code
	if(/*异步操作成功*/){
		resolve(value);
	}else{
		reject(error);
	}
})

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。
resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

调用resolve或reject并不会终结 Promise 的参数函数的执行。

3.Promise.prototype.then()
then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。

采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。

前一个回调函数的结果会作为第二个回调函数的参数。

4.Promise.prototype.catch()
Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。

reject方法的作用，等同于抛出错误。throw new Error()

如果 Promise 状态已经变成resolved，再抛出错误是无效的。
Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。

一般来说，不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。
理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。

5.Promise.prototype.finally()
finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。
finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。
finally本质上是then方法的特例。

6.Promise.all()
Promise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。
p的状态由p1、p2、p3决定，分成两种情况。
（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。
（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。

7.Promise.race()
Promise.race方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。
只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。
Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。

8.Promise.resolve()
将现有对象转为 Promise 对象
Promise.resolve('foo')
// 等价于
new Promise(resolve => resolve('foo'))

Promise.resolve 方法的参数分四种情况
（1）参数是一个 Promise 实例 —— 直接返回原对象
（2）参数是一个thenable对象
将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。
（3）参数不是具有then方法的对象，或根本就不是对象——
返回生成新的Promise对象，状态为resolved。

9.Promise.reject()
Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。
Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。

10.Promise.try() -- 提案
由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。


十六、Iterator 和 for...of 循环
1.Iterator 概念
遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。

2.默认 Iterator 接口
Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环

一种数据结构只要部署了 Iterator 接口，我们就称这种数据结构是“可遍历的”（iterable）。
ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。
Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。

原生具备 Iterator 接口的数据结构如下：
—— Array
数组
for...of循环可以代替数组实例的forEach方法。
JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6 提供for...of循环，允许遍历获得键值。

for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法
for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。

—— Map
—— Set
首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。

—— String
对于字符串来说，for...of循环还有一个特点，就是会正确识别 32 位 UTF-16 字符。

—— TypedArray
—— 函数的 arguments 对象
—— NodeList 对象

有了遍历器接口，数据结构就可以用for...of循环遍历（详见下文），也可以使用while循环遍历。

3.调用 Iterator 接口的场合
1）结构赋值
2）扩展运算符
3）yield*
4）其他场合
由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。
- for...of
- Array.from()
- Map(),Set(),WeakMap(),WeakSet()
- Promise.all()
- Promise.race()

4.字符串的 Iterator 接口

5.Iterator 接口与 Generator 函数

6.遍历器对象的 return()，throw() 

7.for...of 循环

并不是所有类似数组的对象都具有 Iterator 接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。

十七、Generator 函数的语法
1.基本概念
Generator 函数是 ES6 提供的一种异步编程解决方案。
首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。

执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 

Generator 函数特征
1）function 后有星号
2）函数体内部使用 yield 表达式，定义不同的状态
不同的是，调用 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象

调用 next 方法时，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield表达式（或return语句）为止。返回的对象中的value值为yield 的值。

yield 表达式
yield表达式就是暂停标志。
yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。

与 Iterator 接口的关系
 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的Symbol.iterator属性，从而使得该对象具有 Iterator 接口。
Generator 函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。

2.next 方法的参数
yield表达式本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield表达式的返回值。
由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法时，传递参数是无效的。V8 引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。

3.for...of循环
for...of循环可以自动遍历 Generator 函数时生成的Iterator对象，且此时不再需要调用next方法。
原生的 JavaScript 对象没有遍历接口，无法使用for...of循环，通过 Generator 函数为它加上这个接口，就可以用了。还可以加在原型对象的Symbol.iterator 属性上

4.Generator.prototype.throw() 
throw方法抛出的错误要被内部捕获，前提是必须至少执行过一次next方法。
throw方法被捕获以后，会附带执行下一条yield表达式。也就是说，会附带执行一次next方法。
throw命令与g.throw方法是无关的，两者互不影响。
一旦 Generator 执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。

5.Generator.prototype.return() 
Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数。
如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会推迟到finally代码块执行完再执行。

6.next()、throw()、return() 的共同点
它们的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式。

7.yield* 表达式
用来在一个 Generator 函数里面执行另一个 Generator 函数。
yield*后面的 Generator 函数（没有return语句时），等同于在 Generator 函数内部，部署一个for...of循环。
如果被代理的 Generator 函数有return语句，那么就可以向代理它的 Generator 函数返回数据。

8.作为对象属性的 Generator 函数
let obj = {
  * myGeneratorMethod() {
    ···
  }
};

9.Generator 函数的this
Generator 函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。
Generator 函数也不能跟new命令一起用，会报错。
function F() {
  return gen.call(gen.prototype);
}

var f = new F();

10.含义
Generator 与状态机

Generator 与协程 
这种可以并行执行、交换执行权的线程（或函数），就称为协程。
 JavaScript 是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。
 如果将 Generator 函数当作协程，完全可以将多个需要互相协作的任务写成 Generator 函数，它们之间使用yield表达式交换控制权。
 
 Generator 与上下文
 
 
 11.应用
 （1）异步操作的同步化表达
 （2）控制流管理
 （3）部署 Iterator 接口 
 （4）作为数据结构
 
 十八、Generator 函数的异步应用
 1.传统方法
- 回调函数
- 事件监听
- 发布/订阅
- Promise 对象
2.Generator 函数
3.Thunk 函数
Thunk 函数是自动执行 Generator 函数的一种方法。

Thunk 函数的含义
Thunk 函数的定义，它是“传名调用”的一种实现策略，用来替换某个表达式。
任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式。

Thunkify 模块
Thunk 函数并不是 Generator 函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制 Generator 

Thunk 函数的自动流程管理
函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。

4.co 模块

十九、async函数
1.含义
async 函数是什么？一句话，它就是 Generator 函数的语法糖。
async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。

async函数对 Generator 函数的改进，体现在以下四点。
（1）内置执行器。
（2）更好的语义。
（3）更广的适用性。
（4）返回值是 Promise。
进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。

2.基本用法
async 函数有多种使用形式。
// 函数声明
async function foo() {}

// 函数表达式
const foo = async function () {};

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
// 箭头函数
const foo = async () => {};

3.语法
async函数内部return语句返回的值，会成为then方法回调函数的参数。
async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。
class Sleep{
	constructor(timeout){
		this.timeout = timeout;
	}
	then(resolve,reject){
		const startTime = Date.now();
		setTimeout(()=> resolve(Date.now() - startTime),this.timeout);
	}
}
(async () => {
	const actualTime = await new Sleep(1000);
	console.log(actualTime);
})();
任何一个await语句后面的 Promise 对象变为reject状态，那么整个async函数都会中断执行。

错误处理
如果await后面的异步操作出错，那么等同于async函数返回的 Promise 对象被reject。

注意事项：
第一点，前面已经说过，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。
第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。
第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。
第四点，async 函数可以保留运行堆栈。

4.async 函数的实现原理
async 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。

5.与其他异步处理方法的比较
Async 函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将 Generator 写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用 Generator 写法，自动执行器需要用户自己提供。

6.实例：按顺序完成异步操作
7.异步遍历器
ES2018 引入了”异步遍历器“（Async Iterator），为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生。
一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面。同样地，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历。

异步遍历器调用next方法以后，返回一个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。

for await...of 
用于遍历异步的 Iterator 接口。

异步 Generator 函数 
是返回一个异步遍历器对象。
async function* gen() {
  yield 'hello';
}
const genObj = gen();
genObj.next().then(x => console.log(x));

yield* 语句

十九、class 的基本用法
1.简介
基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

类的数据类型就是函数，类本身就指向构造函数。

另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。
Object.keys(Point.prototype)
// []
Object.getOwnPropertyNames(Point.prototype)
// ["constructor","toString"]

类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。

与 ES5 一样，类的所有实例共享一个原型对象。
产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。


Getter 和 Setter
存值函数和取值函数是设置在属性的 Descriptor 对象上的。
可通过 Object.getOwnPropertyDescriptor 获取

注意
（1）严格模式
类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。所以 ES6 实际上把整个语言升级到了严格模式。
（2）不存在变量提升
class 类必须先声明后使用
（3）name 属性
name属性总是返回紧跟在class关键字后面的类名。
（4）Generator 方法
（5）this 的指向

2.静态方法
static 关键字声明的方法，不会被实例继承，而是直接通过类调用
注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。
静态方法可以与非静态方法重名。
子类可以继承父类的静态方法

3.实例属性的新写法
4.静态属性
class Foo {
}
Foo.prop = 1;
因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。

5.私有方法和私有属性 
ES6 不提供，只能通过变通方法模拟实现。
利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。
Reflect.ownKeys()依然可以拿到它们。

6.new.target 属性
该属性一般用在构造函数之中，返回new命令作用于的那个构造函数。
Class 内部调用new.target，返回当前 Class。子类继承父类时，new.target会返回子类。利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。
